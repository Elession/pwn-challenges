# Challenge Name
rollthedice

## Learning Objective
Manipulating PRNG (pseudorandom)

## Description 
Test your luck with the roll of a dice.

## Difficulty:
easy

## Guide
When we look at the source code, there is not really any portion of the code that allows us to perform memory corrruption. 
Seems like we have to play the game by the book.

The game requires us to guess the number on the dice correctly 10 times before we get the flag.

With our current information, what can we do?

### Pseudo-random number generator (PRNG)
**PRNG** is the use of mathematical algorithms to calculate the random value. However, it requires a **seed/start** value which indicates its starting point.

This means that the results are actually **deterministic**.

So if we know the seed value, we can replicate the same set of numbers generated by the algorithm!


### Code vulnerability

```c
srand(time(0)); 
```

`srand` C function sets the seed for the `rand()` function. In this case, it is using the current time as the seed.

So when we exploit, we just use current time as the seed as well.

We also need to note the location of the libc used for this challenge (native library for C functions). This is because the algorithm used for PRNG differs from python.

```shell
$>ldd chall
        linux-vdso.so.1 (0x00007f11cb2dd000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f11cb0ce000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f11cb2df000)
```

So it is located at `/lib/x86_64-linux-gnu/libc.so.6`.


### Exploit

For the script, we need 2 extra python libraries, `time` & `ctypes`.

`time` to use current time.

`ctypes` so we can use the libc library & its functions.

Let's setup the libc first:

```py
from pwn import *
from time import time
from ctypes import CDLL

p = remote("SERVER", PORT)

# use libc library
libc = CDLL('/lib/x86_64-linux-gnu/libc.so.6')

# use the same seed (current time)
seed = int(time())

# use libc srand function to get same PRNG values
libc.srand(seed)
```

`CDLL` from `ctypes` helps us to load the libc, this way we can use the same `srand` function and obtain the same PRNG values.

Now we need to create a loop that runs 10 times to send 10 of the values we generated from PRNG.

```py
for i in range(10):

    # use the same guess
    guess = libc.rand() % 6 + 1  
    
    p.recvuntil("Make your guess (1-6):\n")

    p.sendline(str(guess))
```

`rand()` starts from 0, thus we need to add 1 behind

### Final Solution
```py
from pwn import *
from time import time
from ctypes import CDLL

p = remote("SERVER", PORT)

# use libc library
libc = CDLL('/lib/x86_64-linux-gnu/libc.so.6')

# use the same seed (current time)
seed = int(time())

# use libc srand function to get same PRNG values
libc.srand(seed)
    
for i in range(10):

    # use the same guess
    guess = libc.rand() % 6 + 1  
    
    p.recvuntil("Make your guess (1-6):\n")
    
    p.sendline(str(guess))

p.recvuntil("Correct!\n\n")
print(p.recvall().decode())
```

## Solution
Refer to solve.py

## Hints
1. Look up PRNG
2. where is the algorithm located? Can you replicate it in your script?

## Attached Files
- chall.c
- chall

## Resources
- https://docs.python.org/3/library/ctypes.html
- https://www.tutorialspoint.com/c_standard_library/c_function_srand.htm
- https://www.geeksforgeeks.org/pseudo-random-number-generator-prng/

## Flag
TBD


